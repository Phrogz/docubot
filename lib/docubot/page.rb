# encoding: UTF-8
require 'yaml'
require 'nokogiri'

class DocuBot::Page
	AUTO_ID_ELEMENTS = %w[ h1 h2 h3 h4 h5 h6 legend caption dt ].join(',')

	attr_reader :type, :folder, :file, :meta, :nokodoc, :bundle

	def initialize( bundle, source_path, title=nil )
		puts "#{self.class}.new( #{source_path.inspect}, #{title.inspect}, #{type.inspect} )" if $DEBUG
		title ||= File.basename( source_path ).sub( /\.[^.]+$/, '' ).gsub( '_', ' ' ).sub( /^\d+\s/, '' )
		@bundle = bundle
		@file  = source_path
		if File.directory?( @file )
			@folder = @file
			@file   = Dir[ source_path/'index.*' ][0]
			# Directories without an index.* file now have nil @file
		else
			@folder = File.dirname( @file )
		end
		@type = File.extname( @file )[ 1..-1 ] if @file
		@meta = DocuBot::MetaSection.new( {'title'=>title}, @file )
		@raw  = @meta.__contents__
		@raw = nil if @raw && @raw.empty?

		create_nokodoc
	end
	
	def create_nokodoc
		# Directories with no index.* file will not have any @raw
		# Pages with metasection only will also not have any @raw
		html = if @raw && !@raw.empty?
			html = DocuBot::process_snippets( self, @raw )
			html = DocuBot::convert_to_html( self, html, @type )
		end
		@nokodoc = Nokogiri::HTML::DocumentFragment.parse(html || "")
		auto_id
		auto_section
		@nokodoc
	end
	
	def nokodoc
		@nokodoc ||= create_nokodoc
	end

	# Add IDs to elements that don't have them
	def auto_id
		# ...but only if a toc entry might reference one, or requested.
		if @meta['auto-id'].as_boolean || @meta.toc.as_list.any?{ |toc| !toc['#'] }
			@nokodoc.css( AUTO_ID_ELEMENTS ).each do |node|
				next if node.has_attribute?('id')
				# Strip off the unwanted leading '#'
				node['id'] = DocuBot.id_from_text(node.inner_text)[1..-1]
			end
			dirty_doc
		end
	end
	
	# Wrap siblings of headers in <div class='section'>
	def auto_section
		return if @meta['auto-section']==false
		
		#TODO: Make this a generic nokogiri call on any node (like body) where you can pass in a hierarchy of elements and a wrapper
		stack = []
		@nokodoc.children.each do |node|
			# non-matching nodes will get level of 0
			level = node.name[ /h([1-6])/i, 1 ].to_i
			level = 99 if level == 0

			stack.pop while (top=stack.last) && top[:level]>=level
			stack.last[:div].add_child( node ) if stack.last
			if level<99
				div = Nokogiri::XML::Node.new('div',@nokodoc)
				div.set_attribute( 'class', 'section' )
				node.add_next_sibling(div)
				stack << { :div=>div, :level=>level }
			end
		end
		dirty_doc
	end

	def []( key )
		@meta[key]
	end

	def method_missing( method, *args )
		key=method.to_s
		case key[-1..-1] # the last character of the method name
			when '?' then @meta.has_key?( key[0..-2] )
			when '!','=' then super
			else
				# warn "Unknown attribute #{key.inspect} asked for on #{@file || @folder}" unless @meta.has_key?( key )
				@meta[ key ]
		end
	end
	
	def html_path
		@file ? @file.sub( /[^.]+$/, 'html' ) : ( @folder / 'index.html' )
	end
	
	# Call this if the source generated by the converter would change
	# THIS DESTROYS ANY CUSTOM CHANGES YOU HAVE MADE TO THE NOKODOC
	def dirty_source
		@nokodoc = nil
	end
	
	# Call this after modifying the structure of the nokodoc for the page
	def dirty_doc
		@content_html = nil
	end

	# Call this if the HTML generated by the page template needs to change
	# e.g. for a glossary page.
	def dirty_template
		# to_html doesn't cache anything at this point
		# so nothing needs to be done here
	end
	
	def content_html
		@content_html ||= nokodoc.to_html
	end
	
	def children
		@bundle.toc.children(html_path).map{ |node| node.page }.uniq.compact
	end
	
	def leaf?
		!children.any?{ |page| page != self }
	end
	
	def root
		#FIXME
		"../../../"
	end

	#TODO: cache this is people keep calling to_html and it's a problem
	def to_html
		@meta.template ||= leaf? ? 'page' : 'section'

		master_templates = DocuBot::TEMPLATE_DIR
		source_templates = @bundle.source / '_templates'
		tmpl = source_templates / "#{template}.haml"
		tmpl = master_templates / "#{template}.haml" unless File.exists?( tmpl )
		tmpl = master_templates / "page.haml"        unless File.exists?( tmpl )
		tmpl = IO.read( tmpl )
		haml = Haml::Engine.new( tmpl, DocuBot::Writer::HAML_OPTIONS )
		haml.render( Object.new, :contents=>content_html, :page=>self, :global=>@bundle.global, :root=>root )
	end
	
	def inspect
		"<#{self.class} '#{self.title}' #{@file ? "@file=#{@file.inspect}" : "@folder=#{@folder.inspect}"}>"
	end
	
end
